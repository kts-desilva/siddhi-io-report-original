<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReportSink.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Siddhi io report extension</a> &gt; <a href="index.source.html" class="el_package">org.wso2.extension.siddhi.io.report.sink</a> &gt; <span class="el_source">ReportSink.java</span></div><h1>ReportSink.java</h1><pre class="source lang-java linenums">/*
 *  Copyright (C) 2018 WSO2 Inc. (http://wso2.com) All Rights Reserved.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

package org.wso2.extension.siddhi.io.report.sink;

import org.apache.log4j.Logger;
import org.wso2.extension.siddhi.io.report.report.DynamicReportGenerator;
import org.wso2.extension.siddhi.io.report.report.StaticReportGenerator;
import org.wso2.extension.siddhi.io.report.util.ReportConstants;
import org.wso2.siddhi.annotation.Example;
import org.wso2.siddhi.annotation.Extension;
import org.wso2.siddhi.annotation.Parameter;
import org.wso2.siddhi.annotation.util.DataType;
import org.wso2.siddhi.core.config.SiddhiAppContext;
import org.wso2.siddhi.core.event.Event;
import org.wso2.siddhi.core.exception.ConnectionUnavailableException;
import org.wso2.siddhi.core.exception.SiddhiAppCreationException;
import org.wso2.siddhi.core.stream.output.sink.Sink;
import org.wso2.siddhi.core.util.config.ConfigReader;
import org.wso2.siddhi.core.util.transport.DynamicOptions;
import org.wso2.siddhi.core.util.transport.OptionHolder;
import org.wso2.siddhi.query.api.definition.Attribute;
import org.wso2.siddhi.query.api.definition.StreamDefinition;

import java.io.File;
import java.net.URL;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

//import org.wso2.extension.siddhi.io.report.report.DynamicReportGenerator;

/**
 * This class contains the implementation of siddhi-io-report sink which provides the functionality of publishing
 * data to reports as PDF files through siddhi.
 */

/**
 * Annotation of Siddhi Extension.
 * &lt;pre&gt;&lt;code&gt;
 * eg:-
 * {@literal @}Extension(
 * name = &quot;The name of the extension&quot;,
 * namespace = &quot;The namespace of the extension&quot;,
 * description = &quot;The description of the extension (optional).&quot;,
 * //Sink configurations
 * parameters = {
 * {@literal @}Parameter(name = &quot;The name of the first parameter&quot;, type = &quot;Supprted parameter types.
 *                              eg:{DataType.STRING,DataType.INT, DataType.LONG etc},dynamic=false ,optinal=true/false ,
 *                              if optional =true then assign default value according the type&quot;)
 *   System parameter is used to define common extension wide
 *              },
 * examples = {
 * {@literal @}Example({&quot;Example of the first CustomExtension contain syntax and description.Here,
 *                      Syntax describe default mapping for SourceMapper and description describes
 *                      the output of according this syntax},
 *                      }
 * &lt;/code&gt;&lt;/pre&gt;
 */

@Extension(
        name = &quot;report&quot;,
        namespace = &quot;sink&quot;,
        description = &quot; &quot;,
        parameters = {
                @Parameter(name = &quot;chart&quot;,
                        description = &quot;Chart to be added into the report&quot;,
                        optional = true,
                        defaultValue = &quot;table&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;template&quot;,
                        description = &quot;JRXML template path&quot;,
                        optional = true,
                        defaultValue = &quot;/home/senuri/Projects/Jasper/template/dynamicTemplate.jrxml&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;header&quot;,
                        description = &quot;Header image for the report&quot;,
                        optional = true,
                        defaultValue = &quot;/home/senuri/Projects/Jasper/template/stream-processor.png&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;footer&quot;,
                        description = &quot;Footer image for the report&quot;,
                        optional = true,
                        defaultValue = &quot;/home/senuri/Projects/Jasper/template/stream-processor.png&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;category&quot;,
                        description = &quot;Category variable for the chart&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;series&quot;,
                        description = &quot;Series variable for the chart&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;description&quot;,
                        description = &quot;Description for the report&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;title&quot;,
                        description = &quot;Title of the report&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;subtitle&quot;,
                        description = &quot;Subtitle of the report&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;chart.title&quot;,
                        description = &quot;Title of the chart&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;report.name&quot;,
                        description = &quot;Name of the report generated&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),
                @Parameter(name = &quot;report.uri&quot;,
                        description = &quot;The folder where report is saved&quot;,
                        optional = true,
                        defaultValue = &quot;none&quot;,
                        type = {DataType.STRING}
                ),

                /*@Parameter(name = &quot; &quot;,
                        description = &quot; &quot; ,
                        dynamic = false/true,
                        optional = true/false, defaultValue = &quot; &quot;,
                        type = {DataType.INT, DataType.BOOL, DataType.STRING, DataType.DOUBLE,etc }),
                        type = {DataType.INT, DataType.BOOL, DataType.STRING, DataType.DOUBLE, }),*/
        },
        examples = {
                @Example(
                        syntax = &quot; &quot;,
                        description = &quot; &quot;
                )
        }
)

// for more information refer https://wso2.github.io/siddhi/documentation/siddhi-4.0/#sinks

<span class="fc" id="L181">public class ReportSink extends Sink {</span>
<span class="fc" id="L182">    private static final Logger log = Logger.getLogger(ReportSink.class);</span>
    private OptionHolder optionHolder;
    private StreamDefinition streamDefinition;
<span class="fc" id="L185">    private Map&lt;String, String&gt; reportProperties = new HashMap&lt;&gt;();</span>

    /**
     * The initialization method for {@link Sink}, will be called before other methods. It used to validate
     * all configurations and to get initial values.
     *
     * @param streamDefinition containing stream definition bind to the {@link Sink}
     * @param optionHolder     Option holder containing static and dynamic configuration related
     *                         to the {@link Sink}
     * @param configReader     to read the sink related system configuration.
     * @param siddhiAppContext the context of the {@link org.wso2.siddhi.query.api.SiddhiApp} used to
     *                         get siddhi related utility functions.
     */
    @Override
    protected void init(StreamDefinition streamDefinition, OptionHolder optionHolder, ConfigReader configReader,
                        SiddhiAppContext siddhiAppContext) {
<span class="fc" id="L201">        this.optionHolder = optionHolder;</span>
<span class="fc" id="L202">        this.streamDefinition = streamDefinition;</span>
<span class="fc" id="L203">        validateAndGetParameters();</span>
<span class="fc" id="L204">    }</span>

    /**
     * Returns the list of classes which this sink can consume.
     * Based on the type of the sink, it may be limited to being able to publish specific type of classes.
     * For example, a sink of type file can only write objects of type String .
     *
     * @return array of supported classes , if extension can support of any types of classes
     * then return empty array .
     */
    @Override
    public Class[] getSupportedInputEventClasses() {
<span class="fc" id="L216">        return new Class[]{String.class, Event.class};</span>
    }

    /**
     * Returns a list of supported dynamic options (that means for each event value of the option can change) by
     * the transport
     *
     * @return the list of supported dynamic option keys
     */
    @Override
    public String[] getSupportedDynamicOptions() {
<span class="fc" id="L227">        return new String[]{ReportConstants.REPORT_NAME};</span>
    }


    /**
     * This method will be called when events need to be published via this sink
     *
     * @param payload        payload of the event based on the supported event class exported by the extensions
     * @param dynamicOptions holds the dynamic options of this sink and Use this object to obtain dynamic options.
     * @throws ConnectionUnavailableException if end point is unavailable the ConnectionUnavailableException thrown
     *                                        such that the  system will take care retrying for connection
     */
    @Override
    public void publish(Object payload, DynamicOptions dynamicOptions) throws ConnectionUnavailableException {
<span class="fc" id="L241">        log.info(&quot;payload : &quot; + payload);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (!reportProperties.get(ReportConstants.TEMPLATE).equals(ReportConstants.DEFAULT_TEMPLATE)) {</span>
<span class="fc" id="L243">            StaticReportGenerator staticReportGenerator = new StaticReportGenerator();</span>
<span class="fc" id="L244">            staticReportGenerator.setReportProperties(reportProperties);</span>
<span class="fc" id="L245">            staticReportGenerator.generateReport(payload);</span>
<span class="fc" id="L246">        } else {</span>
<span class="fc" id="L247">            DynamicReportGenerator dynamicReportGenerator = new DynamicReportGenerator();</span>
<span class="fc" id="L248">            dynamicReportGenerator.setReportProperties(reportProperties);</span>
<span class="fc" id="L249">            dynamicReportGenerator.generateReportFromData(payload);</span>
        }
<span class="fc" id="L251">    }</span>

    private void validateAndGetParameters() {
<span class="fc" id="L254">        String template = optionHolder.validateAndGetStaticValue(ReportConstants.TEMPLATE, ReportConstants</span>
                .DEFAULT_TEMPLATE);
<span class="fc" id="L256">        validatePath(template, ReportConstants.TEMPLATE);</span>

<span class="fc" id="L258">        String header = optionHolder.validateAndGetStaticValue(ReportConstants.HEADER, ReportConstants.EMPTY_STRING);</span>
<span class="fc" id="L259">        validatePath(header, ReportConstants.HEADER);</span>

<span class="fc" id="L261">        String footer = optionHolder.validateAndGetStaticValue(ReportConstants.FOOTER, ReportConstants.EMPTY_STRING);</span>
<span class="fc" id="L262">        validatePath(footer, ReportConstants.FOOTER);</span>

<span class="fc" id="L264">        String chart = optionHolder.validateAndGetStaticValue(ReportConstants.CHART, ReportConstants.DEFAULT_CHART);</span>
<span class="fc" id="L265">        validateChart(chart);</span>

<span class="fc" id="L267">        String seriesVariable = optionHolder.validateAndGetStaticValue(ReportConstants.SERIES, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L269">        validateVariable(ReportConstants.SERIES, seriesVariable);</span>

<span class="fc" id="L271">        String categoryVariable = optionHolder.validateAndGetStaticValue(ReportConstants.CATEGORY, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L273">        validateVariable(ReportConstants.CATEGORY, categoryVariable);</span>

<span class="fc" id="L275">        String description = optionHolder.validateAndGetStaticValue(ReportConstants.DESCRIPTION, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L277">        validateStringParameters(ReportConstants.DESCRIPTION, description);</span>

<span class="fc" id="L279">        String reportTitle = optionHolder.validateAndGetStaticValue(ReportConstants.TITLE, ReportConstants</span>
                .DEFAULT_TITLE);
<span class="fc" id="L281">        validateStringParameters(ReportConstants.TITLE, reportTitle);</span>

<span class="fc" id="L283">        String reportSubtitle = optionHolder.validateAndGetStaticValue(ReportConstants.SUBTITLE, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L285">        validateStringParameters(ReportConstants.SUBTITLE, reportSubtitle);</span>

<span class="fc" id="L287">        String chartTitle = optionHolder.validateAndGetStaticValue(ReportConstants.CHART_TITLE, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L289">        validateStringParameters(ReportConstants.CHART_TITLE, chartTitle);</span>

<span class="fc" id="L291">        String outPath = optionHolder.validateAndGetStaticValue(ReportConstants.URI, ReportConstants</span>
                .EMPTY_STRING);
<span class="fc" id="L293">        validatePath(outPath, ReportConstants.URI);</span>

<span class="fc" id="L295">        String reportName = optionHolder.validateAndGetStaticValue(ReportConstants.REPORT_NAME, ReportConstants</span>
                .DEFAULT_REPORT_NAME);
<span class="fc" id="L297">        validateStringParameters(ReportConstants.REPORT_NAME, reportName);</span>
<span class="fc" id="L298">        validateMapType();</span>
<span class="fc" id="L299">    }</span>

    private void validateMapType() {
<span class="fc" id="L302">        String mapType = streamDefinition.getAnnotations().get(0).getAnnotations().get(0).getElements().get(0)</span>
<span class="fc" id="L303">                .getValue();</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (!mapType.equals(&quot;json&quot;)) {</span>
<span class="nc" id="L305">            throw new SiddhiAppCreationException(&quot;Invalid map type &quot; + mapType + &quot;Only JSON map type is allowed.&quot;);</span>
        }
<span class="fc" id="L307">    }</span>

    private void validateStringParameters(String property, String value) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (property.equals(ReportConstants.REPORT_NAME)) {</span>
<span class="fc" id="L311">            String dynamicOptionPattern = &quot;(\\{\\w*\\})&quot;;</span>
<span class="fc" id="L312">            Pattern pattern = Pattern.compile(dynamicOptionPattern);</span>
<span class="fc" id="L313">            Matcher matcher = pattern.matcher(value);</span>

<span class="fc bfc" id="L315" title="All 2 branches covered.">            if (matcher.find()) {</span>
<span class="fc" id="L316">                String matchingPart = matcher.group().substring(1, matcher.group().length() - 1);</span>
<span class="fc" id="L317">                Attribute matchingAttribute = streamDefinition.getAttributeList().stream()</span>
<span class="fc" id="L318">                        .filter(attribute -&gt; attribute.getName().equals(matchingPart))</span>
<span class="fc" id="L319">                        .findAny()</span>
<span class="fc" id="L320">                        .orElse(null);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                if (matchingAttribute != null) {</span>
<span class="fc" id="L322">                    reportProperties.put(ReportConstants.REPORT_DYNAMIC_VALUE, matcher.group());</span>
                } else {
<span class="fc" id="L324">                    throw new SiddhiAppCreationException(&quot;Invalid Property '&quot; + matchingPart + &quot;'. No such &quot; +</span>
                            &quot;parameter in the stream definition&quot;);
                }
            }
        }
<span class="fc" id="L329">        this.reportProperties.put(property, value);</span>
<span class="fc" id="L330">    }</span>

    private void validateVariable(String property, String chartVariable) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (!chartVariable.isEmpty()) {</span>
<span class="fc" id="L334">            List&lt;Attribute&gt; attributeList = streamDefinition.getAttributeList();</span>
<span class="fc" id="L335">            boolean validAttributeFound = false;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">            for (Attribute attribute : attributeList) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">                if (attribute.getName().equals(chartVariable)) {</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                    if (property.equals(ReportConstants.SERIES)) {</span>
<span class="fc" id="L339">                        Attribute.Type attributeType = attribute.getType();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                        if (!isNumeric(attributeType)) {</span>
<span class="fc" id="L341">                            throw new SiddhiAppCreationException(chartVariable + &quot;is invalid. Provide a numeric &quot; +</span>
                                    &quot;series column.&quot;);
                        }
                    }
<span class="fc" id="L345">                    validAttributeFound = true;</span>
                }
<span class="fc" id="L347">            }</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (validAttributeFound) {</span>
<span class="fc" id="L349">                reportProperties.put(property, chartVariable);</span>
            } else {
<span class="nc" id="L351">                throw new SiddhiAppCreationException(&quot;Invalid property &quot; + chartVariable + &quot; for &quot; + property);</span>
            }
        }
<span class="fc" id="L354">    }</span>

    private boolean isNumeric(Attribute.Type attributeType) {
<span class="pc bfc" id="L357" title="All 2 branches covered.">        switch (attributeType) {</span>
            case INT:
            case LONG:
            case DOUBLE:
            case FLOAT:
<span class="fc" id="L362">                return true;</span>
            default:
<span class="fc" id="L364">                return false;</span>
        }
    }

    private void validatePath(String path, String parameter) {
<span class="fc" id="L369">        Path file = new File(path).toPath();</span>
<span class="fc" id="L370">        ClassLoader classLoader = ReportSink.class.getClassLoader();</span>
<span class="fc" id="L371">        URL resourceFile = classLoader.getResource(path);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (resourceFile != null) {</span>
<span class="fc" id="L373">            file = new File(resourceFile.getFile()).toPath();</span>
        }
<span class="fc" id="L375">        FileSystem fileSystem = FileSystems.getDefault();</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (!Files.exists(file)) {</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (!path.equals(ReportConstants.DEFAULT_TEMPLATE)) {</span>
<span class="fc" id="L378">                throw new SiddhiAppCreationException(path + &quot; does not exists. &quot; + parameter + &quot; should be a valid &quot; +</span>
                        &quot;path&quot;);
            }
        }

<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (parameter.equals(ReportConstants.TEMPLATE)) {</span>
<span class="fc" id="L384">            PathMatcher matcher = fileSystem.getPathMatcher(&quot;glob:**.jrxml&quot;);</span>
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">            if (!path.isEmpty()) {</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                if (!matcher.matches(file)) {</span>
<span class="nc" id="L387">                    throw new SiddhiAppCreationException(parameter + &quot; is invalid.&quot; + ReportConstants.TEMPLATE + &quot; &quot; +</span>
                            &quot;should have a JRXML template&quot;);
                } else {
<span class="fc" id="L390">                    reportProperties.put(parameter, path);</span>
                }
            }
        }

<span class="fc bfc" id="L395" title="All 4 branches covered.">        if (parameter.equals(ReportConstants.HEADER) || parameter.equals(ReportConstants.FOOTER)) {</span>
<span class="fc" id="L396">            PathMatcher matcher = fileSystem.getPathMatcher(&quot;glob:**.{png,jpeg,JPEG}&quot;);</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">            if (!path.isEmpty()) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                if (!matcher.matches(file)) {</span>
<span class="nc" id="L399">                    throw new SiddhiAppCreationException(&quot;Invalid path &quot; + path + &quot;. &quot; + parameter + &quot; should be an &quot; +</span>
                            &quot;image&quot;);
                } else {
<span class="nc" id="L402">                    reportProperties.put(parameter, path);</span>
                }
            }
        }

<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (parameter.equals(ReportConstants.URI)) {</span>
<span class="fc" id="L408">            reportProperties.put(parameter, path);</span>
        }
<span class="fc" id="L410">    }</span>

    private void validateChart(String chart) {
<span class="fc" id="L413">        List&lt;String&gt; validChartTypes = Stream.of(ReportConstants.ChartTypes.values()).map(ReportConstants</span>
<span class="fc" id="L414">                .ChartTypes::name).collect(Collectors.toList());</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (!validChartTypes.contains(chart.toUpperCase(Locale.ENGLISH))) {</span>
<span class="fc" id="L416">            throw new SiddhiAppCreationException(chart + &quot; is not a valid chart type. &quot; +</span>
                    &quot;Only table,line,bar,pie charts are supported.&quot;);
        }
<span class="fc" id="L419">        reportProperties.put(ReportConstants.CHART, chart);</span>
<span class="fc" id="L420">    }</span>

    /**
     * This method will be called before the processing method.
     * Intention to establish connection to publish event.
     *
     * @throws ConnectionUnavailableException if end point is unavailable the ConnectionUnavailableException thrown
     *                                        such that the  system will take care retrying for connection
     */
    @Override
    public void connect() throws ConnectionUnavailableException {
        // do nothing
<span class="fc" id="L432">    }</span>

    /**
     * Called after all publishing is done, or when {@link ConnectionUnavailableException} is thrown
     * Implementation of this method should contain the steps needed to disconnect from the sink.
     */
    @Override
    public void disconnect() {
        // do nothing
<span class="fc" id="L441">    }</span>

    /**
     * The method can be called when removing an event receiver.
     * The cleanups that have to be done after removing the receiver could be done here.
     */
    @Override
    public void destroy() {
        // do nothing
<span class="fc" id="L450">    }</span>

    /**
     * Used to collect the serializable state of the processing element, that need to be
     * persisted for reconstructing the element to the same state on a different point of time
     * This is also used to identify the internal states and debugging
     *
     * @return all internal states should be return as an map with meaning full keys
     */
    @Override
    public Map&lt;String, Object&gt; currentState() {
<span class="nc" id="L461">        return null;</span>
    }

    /**
     * Used to restore serialized state of the processing element, for reconstructing
     * the element to the same state as if was on a previous point of time.
     *
     * @param map the stateful objects of the processing element as a map.
     *            This map will have the  same keys that is created upon calling currentState() method.
     */
    @Override
    public void restoreState(Map&lt;String, Object&gt; map) {
        // no state
<span class="nc" id="L474">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>